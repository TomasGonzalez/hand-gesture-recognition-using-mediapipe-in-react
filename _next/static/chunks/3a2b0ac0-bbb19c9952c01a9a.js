"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{6325:function(e,t,s){s.d(t,{W:function(){return c}});var n=s(9296),i=s(1944),o=s(588),r=s(9897),a=s(2931),l=s(1977),u=s(7538),h=s(1653),p=s(7385),d=s(1111),f=s(4396),y=s(163);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */ class c extends y.mh{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){let t=this.getClassName().toLowerCase();this.name=(0,i.s)(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],a.Tw(this.inputs).length!==this.inputs.length)throw new o.nu(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);for(let s of(a.Tw(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[],this.outputs)){let n=s.sourceLayer,r=s.nodeIndex,l=s.tensorIndex;this.outputLayers.push(n),this.outputLayersNodeIndices.push(r),this.outputLayersTensorIndices.push(l)}for(let u of this.inputs){let h=u.sourceLayer,p=u.nodeIndex,d=u.tensorIndex;a.hu(0===p,"input layer has >1 nodes"),a.hu(0===d,"input layer has >1 tensors"),this.inputLayers.push(h),this.inputLayersNodeIndices.push(p),this.inputLayersTensorIndices.push(d)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let m=0;m<this.inputLayers.length;m++){let g=this.inputLayers[m];if(!(g instanceof f.l))throw TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${m} (0-based) originates from layer type ${g.getClassName()}.`);this.inputNames.push(g.name),this.feedInputShapes.push(g.batchInputShape),this.feedInputNames.push(g.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);let L={},w={},N={},I={},$={},T=[],C=(e,t,s,n,i,r)=>{(null==n||null==i||null==r)&&(n=e.sourceLayer,i=e.nodeIndex,r=e.tensorIndex);let a=n.inboundNodes[i];if(-1!==s.indexOf(a))throw new o.LH(`The tensor ${e.name} at layer "${n.name}" is part of a cycle.`);if(-1!==t.indexOf(a))return;this.containerNodes.add(c.nodeKey(n,i)),n.id in $||($[n.id]=Object.keys($).length),-1===s.indexOf(a)&&s.push(a);let l=a.inboundLayers.length;for(let u=0;u<l;u++){let h=a.inputTensors[u],p=a.inboundLayers[u],d=a.nodeIndices[u],f=a.tensorIndices[u];C(h,t,s,p,d,f)}for(t.push(a);s.indexOf(a)>=0;)s.splice(s.indexOf(a),1);T.push(a)},_=[],x=[];for(let k of this.outputs)C(k,_,x);let O=T.slice().reverse();for(let D of O){w[D.id]=D,D.id in L||(L[D.id]=0);let v=L[D.id],A=null==N[D.outboundLayer.id]?0:N[D.outboundLayer.id];v=Math.max(v,A),N[D.outboundLayer.id]=v,I[D.outboundLayer.id]=D.outboundLayer,L[D.id]=v;for(let S=0;S<D.inboundLayers.length;S++){let W=D.inboundLayers[S],z=D.nodeIndices[S],j=W.inboundNodes[z],M=null==L[j.id]?0:L[j.id];L[j.id]=Math.max(v+1,M),w[j.id]=j}}let B={};for(let E in L){let K=L[E];K in B||(B[K]=[]),B[K].push(w[E])}let Z={};for(let J in N){let V=N[J];V in Z||(Z[V]=[]),Z[V].push(I[J])}let q=Object.keys(Z).map(e=>parseInt(e,10)).sort(a.L7);for(let R of(this.layers=[],q)){let F=Z[R];for(let G of(F.sort((e,t)=>{let s=$[e.id],n=$[t.id];return s<n?-1:s>n?1:0}),F))G instanceof c&&this.internalContainerRefs.push(G),this.layers.push(G)}this.layersByDepth=Z,q=Object.keys(B).map(e=>parseInt(e,10)).sort(a.L7);let H=this.inputs.slice(),P=[];for(let Q of q)for(let U of B[Q]){let X=U.outboundLayer;if(null!=X){for(let Y of U.inputTensors)if(-1===H.indexOf(Y))throw new o.LH(`Graph disconnected: cannot obtain value for tensor ${Y} at layer "${X.name}". The following previous layers were accessed without issue: ${P}`);for(let ee of U.outputTensors)H.push(ee);P.push(X.name)}}this.nodesByDepth=B;let et=this.layers.map(e=>e.name);for(let es of et){let en=et.filter(e=>e===es).length;if(1!==en)throw new o.LH(`The name "${es}" is used ${en} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(et))}this.outboundNodes=[],this.inboundNodes=[],new y.NB({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let s of this.internalContainerRefs)e.numDisposedVariables+=s.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new o.nu("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let s=[];for(let n of this.layers)s.push(...n.trainableWeights);return s.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let s={},n=0;for(let i of this.layers)for(let r of i.weights){if(null!=s[r.originalName])throw new o.nu(`Duplicate weight name: ${r.originalName}`);s[r.originalName]=r,n++}let a=[];for(let l in e){let u=l;if(null==s[l]){let p=l.split("/"),d=p.slice(0,-2).concat([p[p.length-1]]);u=d.join("/")}if(null!=s[u])a.push([s[u],e[l]]);else if(t)throw new o.nu(`Provided weight data has no target variable: ${l}`);delete s[u]}if(t){let f=[];for(let y in s)f.push(y);if(f.length>0)throw new o.nu(`${f.length} of ${n} weights are not set: ${f}`)}(0,h.zb)(a)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${p.i}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let s=(0,l.q)(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return(0,n.lub)(()=>{e=a.zZ(e);let s=new d.l2;for(let n=0;n<this.inputs.length;++n)s.add(this.inputs[n],e[n]);return(0,d.ht)(this.outputs,s,t)})}computeMask(e,t){return(0,n.lub)(()=>{e=a.zZ(e);let s;return s=null==t?a.JE(null,e.length):a.zZ(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){let t=u.x6(e);if(t.length!==this.inputLayers.length)throw new o.nu(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let s={};for(let n=0;n<t.length;n++){let i=this.inputLayers[n],r=t[n],l=i.name+"_0_0";s[l]=r}let h=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(a.L7);if(h.length>1)for(let p of h){let d=this.nodesByDepth[p];for(let f of d){let y=f.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(y.id))continue;let c=[];for(let m=0;m<f.inboundLayers.length;m++){let g=f.inboundLayers[m],b=f.nodeIndices[m],L=f.tensorIndices[m],w=`${g.name}_${b}_${L}`,N=s[w];c.push(N)}let I=y.computeOutputShape(a.Bq(c)),$=u.x6(I),T=y.inboundNodes.indexOf(f);for(let C=0;C<$.length;C++){let _=`${y.name}_${T}_${C}`;s[_]=$[C]}}}let x=[],k=[];for(let O=0;O<this.outputLayers.length;O++){let D=this.outputLayers[O],v=this.outputLayersNodeIndices[O],A=this.outputLayersTensorIndices[O],S=`${D.name}_${v}_${A}`;k.push(S)}for(let W=0;W<k.length;W++){let z=k[W];a.hu(z in s),x.push(s[z])}return a.Bq(x)}runInternalGraph(e,t){null==t&&(t=a.JE(null,e.length));let s={};for(let n=0;n<this.inputs.length;++n){let i=this.inputs[n],r=e[n],l=t[n];s[i.id]=[r,l]}let u=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(a.L7);for(let h of u){let p=this.nodesByDepth[h];for(let d of p){let f=d.outboundLayer,y=d.inputTensors,c=d.outputTensors,m=[];for(let g of y)g.id in s&&m.push(s[g.id]);if(m.length===y.length){let b={},L,w,N,I;if(null!=d.callArgs&&(b=d.callArgs),1===m.length){let[$,T]=m[0];null==b.mask&&(b.mask=T),N=a.zZ(f.call($,b)),I=a.zZ(f.computeMask($,T)),L=[$],w=[T]}else L=m.map(e=>e[0]),w=m.map(e=>e[1]),null==b.mask&&(b.mask=w),N=a.zZ(f.call(L,b)),I=a.zZ(f.computeMask(L,w));if(f.activityRegularizer)throw new o.nj("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<c.length;++C){let _=c[C],x=N[C],k=I[C];s[_.id]=[x,k]}}}}let O=[],D=[],v=[];for(let A of this.outputs){a.hu(A.id in s,`Could not compute output ${A.name} : ${A.id}`);let[S,W]=s[A.id];v.push(S.shape),O.push(S),D.push(W)}return[O,D,v]}buildNodeConversionMap(e){let t={},s;for(let n of this.layers){s=n instanceof c?1:0;for(let i=0;i<n.inboundNodes.length;i++){let o=c.nodeKey(n,i);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(null!=t){if(!(this.layers.length<=t))return this.layers[t];throw new o.nu(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`)}if(null==e)throw new o.nu("Provide either a layer name or layer index");for(let s of this.layers)if(s.name===e)return s;throw new o.nu(`No such layer: ${e}`)}calculateLosses(){return(0,n.lub)(()=>{let e=[];for(let t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){let n=c.nodeKey(t,s);this.containerNodes.has(n)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(let n of this.layers){let i=n.getClassName(),o=n.getConfig(),r=[];for(let a=0;a<n.inboundNodes.length;a++){let l=n.inboundNodes[a],u=c.nodeKey(n,a),h={};if(this.containerNodes.has(u)){if(l.callArgs)try{JSON.stringify(l.callArgs),h=l.callArgs}catch(p){console.warn(`Layer ${n.name} was passed non-serializable keyword arguments: ${l.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(l.inboundLayers.length>0){let d=[];for(let f=0;f<l.inboundLayers.length;f++){let y=l.inboundLayers[f],m=l.nodeIndices[f],g=l.tensorIndices[f],b=c.nodeKey(y,m),L=t[b];null==L&&(L=0),d.push([y.name,L,g,h])}r.push(d)}}}let w={};w.name=n.name,w.className=i,w.config=o,w.inboundNodes=r,s.push(w)}e.layers=s;let N=[];for(let I=0;I<this.inputLayers.length;I++){let $=this.inputLayers[I],T=this.inputLayersNodeIndices[I],C=c.nodeKey($,T);if(!this.containerNodes.has(C))continue;let _=t[C];null==_&&(_=0);let x=this.inputLayersTensorIndices[I];N.push([$.name,_,x])}e.inputLayers=N;let k=[];for(let O=0;O<this.outputLayers.length;O++){let D=this.outputLayers[O],v=this.outputLayersNodeIndices[O],A=c.nodeKey(D,v);if(!this.containerNodes.has(A))continue;let S=t[A];null==S&&(S=0);let W=this.outputLayersTensorIndices[O];k.push([D.name,S,W])}return e.outputLayers=k,e}static fromConfig(e,t,s={},n=!1){let i={},l={};function u(e,t){e.name in l?l[e.name].push(t):l[e.name]=[t]}function h(e,t){let s=[],n;for(let o of t){let r=o[0],l=o[1],h=o[2];if(n=null==o[3]?{}:o[3],!(r in i)){u(e,t);return}let p=i[r];if(p.inboundNodes.length<=l){u(e,t);return}let d=p.inboundNodes[l];s.push(d.outputTensors[h])}s.length>0&&e.apply(a.Bq(s),n)}function p(e){let s=e.name,a=(0,r.v)(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(n),i[s]=a;let l=e.inboundNodes;l.forEach(e=>{if(!(e instanceof Array))throw new o.nu(`Corrupted configuration, expected array for nodeData: ${e}`);u(a,e)})}let d=t.name,f=t.layers;for(let y of f)p(y);for(;!a.nK(l);)for(let c of f){let m=i[c.name];if(m.name in l){let g=l[m.name];for(let b of(delete l[m.name],g))h(m,b)}}let L=[],w=[],N=t.inputLayers;for(let I of N){let $=I[0],T=I[1],C=I[2];a.hu($ in i);let _=i[$],x=_.inboundNodes[T].outputTensors;L.push(x[C])}let k=t.outputLayers;for(let O of k){let D=O[0],v=O[1],A=O[2];a.hu(D in i);let S=i[D],W=S.inboundNodes[v].outputTensors;w.push(W[A])}return new e({inputs:L,outputs:w,name:d})}get stateful(){if(this._stateful)throw new o.nu("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){(0,n.lub)(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}}}]);